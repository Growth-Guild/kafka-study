## 5장(프로듀서의 내부 동작 원리와 구현)

* 파티셔너
  * 한개의 토픽은 성능을 위해 한개 이상의 파티션으로 분할되어 저장된다
  * 메시지의 키 값을 기준으로 해싱되어 어느 파티션으로 보낼 지 결정되기 때문에
  나중에 파티션을 추가하면 같은 키 값이라도 다른 파티션에 저장될 수 있다

* 라운드 로빈 전략
  * 메시지의 키 값은 필수가 아니므로, 키 값이 없을 경우 라운드 로빈 방식으로 파티션에 분할한다
  * 라운드 로빈 방식의 문제점은, 프로듀서 내부적으로 카프카에 보낼 때 메시지를 파티션 단위로 배치 처리 하는데
  파티션과 배치 사이즈가 클 경우 충분한 메시지에도 배치 사이즈를 채우지 못해서 전송을 못하는 경우가 생김
  * 해당 부분을 보완하기 위해 스티키 파티셔닝 전략이 개발되었다
  
* 스티키 파티셔닝 전략
  * 라운드 로빈의 단점을 보완하기 위해, 프로듀서에서 특정 파티션의 배치를 먼저 채워서 전송하는 방식
  
  ![producer](./picture/producer.PNG)
* 프로듀서 옵션들
  * buffer.memory : 카프카로 메시지들을 전송하기 위해 담아두는 버퍼 메모리
  * batch.size : 배치 전송을 위해 메시지들을 묶는 단위, 기본 16KB
  * linger.ms : 배치 전송을 위해 버퍼 메모리에서 대기하는 시간, 기본 0ms

* 프로듀서 메시지 전송 방식 종류
  * 적어도 한 번 전송
  * 최대 한 번 전송
  * 정확히 한 번 전송

* 적어도 한 번 전송
  * 최소 한번 이상의 전송이 보장되는 방식이며 아래 그림과 같이 동작한다.
  ![at_least_once](./picture/at_least_once.PNG)
  * 흐름을 정리하면, 전송 후 ACK 를 받지 못하면 계속 재 전송하는 동작이다
  * 브로커에서 메시지를 받았으나, 네트워크 등의 문제로 ACK 를 프로듀서에서 못 받고 재전송할 수 있기 때문에 최소 한번 이상 동작이다
* 최대 한 번 전송
  * 최대로 한 번 전송이 보장되는 방식이며 아래 그림과 같이 동작한다.
  ![max_once](./picture/max_once.PNG)
  * 흐름을 정리하면, ACK 응답을 받지 못하여도 계속해서 다음 메시지를 전송한다
  * 해당 방식에서는 사실 ACK 가 필요하지 않으며, 데이터 유실을 감안하더라도 처리량이 중요한 대량의 로그
  데이터 저장 시 사용한다
* 중복 없는 전송(멱등성 전송)
  * 프로듀서의 메시지를 중복 없이 전송이 보장되는 방식이다
  * 멱등성이란? 
    * 동일한 작업을 여러번 수행하더라도, 결과가 달라지지 않는 것을 의미
    * 카프카에서는 프로듀서를 통해 동일한 메시지를 중복 전송하더라도 카프카에는 한번만 저장되는 것을 의미
  * 아래 그림과 같이 동작한다
  ![exactly_once](./picture/exactly_once.PNG)
  * 흐름을 정리하면, 프로듀서는 메시지의 헤더에 PID(producer id) 와 메시지의 시퀀스를 전송하며
  브로커는 받은 메시지의 PID 와 시퀀스를 메모리에 저장하고 있다. 미처 브로커에서 ACK 응답을 보내지 못했더라도
  프로듀서에서 재전송하는 PID 와 시퀀스 값을 비교하여 이미 저장된 메시지면 저장하지 않고 ACK 응답만을 보낸다
  * 해당 전송 방식에는 PID, 시퀀스를 확인하므로 오버헤드가 있다, 하지만 생각보다 높은 편은 아니다(-20%)


  