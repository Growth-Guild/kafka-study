## 6장(컨슈머 오프셋 관리)

* 컨슈머 오프셋 관리
  * 컨슈머 그룹은 읽어온 메시지의 오프셋 및 컨슈머 그룹, 토픽, 파티션 등의 정보를  __consumer_offsets 토픽에 저장한다 
  * 토픽에 저장되는 오프셋은 저장할 때, 컨슈머가 읽은 오프셋이 아니라 다음에 읽어올 오프셋을 저장한다

* 그룹 코디네이터
  * 컨슈머 그룹 내의 컨슈머들은 언제든지 추가되고 삭제될 수 있다. 이럴때마다 컨슈머 그룹은 각 컨슈머들에게 작업을 균등하게 분배해야 하며 이 작업을
  리밸런싱 이라고 한다
  * 트랜잭션 코디네이터처럼, 컨슈머 그룹의 안정적인 관리를 위해 코디네이터가 존재하며 이를 그룹 코디네이터라고 한다
  * 그룹 코디네이터는 브로커 중 하나에 위치하며, 구독한 토픽의 파티션들과 그에 대한 컨슈머 그룹을 트래킹해서, 변경 시 컨슈머 리밸런싱 동작을 발생시킨다
  * 컨슈머 그룹과 코디네이터의 상호 작용은 아래 그림과 같다
  ![consumer_group](./picture/consumer_group.PNG)
  * 컨슈머 그룹 내의 컨슈머들의 변경을 감지하기 위해서 그룹 코디네이터와 컨슈머들은 주기적으로 서로 하트비트를 주고 받으며 이는 설정을 통해 간격을 조정할 수 있다
  * 컨슈머 리밸런싱 동작은 비용이 크므로, 리밸런싱을 최소화 하는 방향으로 설정되어야 한다. 특정한 경우가 아닌 이상 기본값 설정이 권장된다
  
* 스태틱 멤버십
  * 컨슈머 리밸런싱 동작은 비용이 크다고 했는데, 설정 변경이나 컨슈머 재기동이 필요한 경우에는 리밸런싱이 일어나게 된다. 이 비용을 없애기 위해서 
  카프카 2.3 버전부터 스태틱 멤버십 이라는 개념이 도입되었다
  * 스태틱 멤버십이란, 컨슈머마다 구별할 수 있는 ID를 적용함으로써 그룹 내에서 컨슈머가 재시작 등으로 그룹에서 나갔다가 다시 합류하더라도 
  리밸런싱이 일어나지 않게 한다
  * 컨슈머 인스턴스 별로 group.instance.id 를 적용하면, 스태틱 멤버십을 사용할 수 있다
  * session.timeout.ms 에 지정된 값 이상으로 컨슈머가 다시 시작되지 않으면, 스태틱 멤버십을 적용하였더라도 리밸런싱이 일어나니 설정 시간을 잘
  고려해야 한다
  * peter-topic06 을 생성 후(리플리케이션 팩터 3, 파티션 3) 3개의 인스턴스에서 컨슈머를 실행하고
    /usr/local/kafka/bin/kafka-consumer-groups.sh --bootstrap-server peter-kafka01.foo.bar:9092 --group peter-consumer01 --describe 명령어를 통해
  컨슈머의 매핑 상태를 확인하면 각 서버(인스턴스)별로 파티션이 매핑된 것을 확인할 수 있다
  ![rebalance_1](./picture/rebalance_1.PNG)
  
  * 한 컨슈머를 종료한 뒤에 확인해보면, 아래와 같이 종료된 컨슈머는 제외되고 리밸런싱이 일어난 것을 확인할 수 있다
  ![rebalance_2](./picture/rebalance_2.PNG)
  
  * 스태틱 멤버십을 사용할 경우에도, session.timeout.ms 만큼 이상이 지나면 위와 같이 리밸런싱이 일어난다
  * 그럼 스태틱 멤버십을 통해 컨슈머가 유지되는 동안은 읽을 수 없는것인가?

