## 4장(카프카의 내부 동작 원리와 구현)

* 리플리케이션 동작 개요
  * 애플리케이션의 고가용성을 위해 리플리케이션(복제본 생성)은 필수적인 요소다
  * replication factor (복제본 생성 수) 옵션을 통해서 각 토픽의 리플리케이션 갯수를 지정할 수 있다.
  * kafka-topics.sh 의 --describe 옵션을 통해서 아래와 같이
  파티션의 개수, 리플리케이션 팩터 수, 리플리케이션이 존재하는 브로커등의 상세 정보를 확인할 수 있다
    ![describe](./picture/peter-test01-describe.PNG)
  * kafka-dump-log.sh --print-data-log --files ${세그먼트 파일} 을 통해 세그먼트의 시작 오프셋, 메시지 등의 상세 정보를
  아래와 같이 확인할 수 있다.
    ![dump](./picture/peter-dump.PNG)
  * N 개의 리플리케이션이 있을 경우, N-1 까지의 브로커 장애시에도 메시지 손실없이 안정적으로 메시지를 주고받을 수 있다

* 리더와 팔로워
  * 각 리플리케이션은 리더와 팔로워로 구분된다. 리더는 한개만 존재하며 프로듀서/컨슈머는 리더에만 데이터를 전송/읽는다
  * 팔로워들은 리더에 문제가 생겼을 경우 리더가 될 준비를 하며, 지속적으로 리더의 변경사항을 반영한다

* 복제 유지와 커밋
  * 리더와 팔로워는 ISR(InSyncReplica) 라는 논리적 그룹으로 묶여 있으며 해당 그룹에 속하는 팔로워만이
  리더가 될 자격을 부여한다
  * 리더는 팔로워들이 특정 주기마다 메시지 요청을 하는지 감시하며, 요청이 오지 않는 팔로워는 ISR 그룹에서 제외시킨다
  (ISR 목록은 토픽 상세보기를 통해 확인가능)
  * 모든 팔로워가 메시지를 복제하면, 리더는 내부적으로 하이워터마크라는 커밋 오프셋을 저장하며, 하이워터마크된 메시지만
  컨슈머에서 읽어갈 수 있다
  * 모든 팔로워가 메시지를 복제하지 않은 상태에서 컨슈머에게 제공하면 아래와 같이 새로운 리더가 선출되었을 경우 데이터
  싱크가 맞지 않는 현상이 발생하게 된다
    ![new_leader_consumer](./picture/new_leader_consumer.PNG)
  * 성능 향상을 위해, 리더는 팔로워가 데이터를 잘 저장했는지 여부를 통신 응답으로 확인(ACK) 하지 않으며
  그대신 팔로워가 데이터 요청시 응답에 추가적으로 새로운 메시지가 있다고 알리게 된다
  * /data/kafka-logs/replication-offset-checkpoint 파일에 마지막 오프셋 위치가 아래와 같이 각 브로커에서 저장되게 된다
    > peter-test01 0 6

* 리더와 팔로워의 단계별 리플리케이션 동작
  * 다른 메시지징 큐 시스템과는 다르게, 카프카는 데이터 처리 성능 향상을 위해 팔로워들이 데이터를 잘 저장했는지 확인하는 ACK 통신을 
  하지 않는다
  * 그렇다면 어떻게 안정적으로 데이터를 저장(리플리케이션) 했는지 알 수 있을까?
  * 팔로워들은 리더에게 기본적으로 계속해서 현재 저장된 오프셋 이후의 데이터를 요청한다
  * 리더는 모든 팔로워들에게 특정 오프셋 이후의 데이터 요청이 오면, 오프셋 이전의 데이터는 복제된것으로 간주하고 커밋(하이 워터마크) 처리한다
  * 수행 과정을 정리하면 아래와 같다
    ![replication_process](./picture/replication_process.PNG)

* 리더에포크와 복구
  * 파티션들의 복구 동작 시 메시지 일관성을 위해서 리더에포크라는 것이 존재한다
  * 하이워터마크가 있음에도 리더에포크가 존재하는 이유는 무엇인가? 브로커 장애 복구 특정 상황에서 메시지가 유실될 수 있기 때문
  * 아래 그림과 같이 팔로워에서 message2 요청 -> 리더의 하이워터마크 증가 -> 팔로워에서 message2 리플리케이션 했으나 하이워터마크 증가 미반영 상태일 경우
    ![leader_epoch_1](./picture/leader_epoch_1.PNG)
  * 해당 상태에서 팔로워가 장애 발생, 장애복구 시 자신의 하이워터마크 이상의 메시지는 삭제한다
    ![leader_epoch_2](./picture/leader_epoch_2.PNG)
  